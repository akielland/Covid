# -*- coding: utf-8 -*-
"""Project2_INSTK5000.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FnBhGKN1kTYi_-m20RwuSyyNkf1uGTon
"""

## Symptom list: Covid-Recovered, Covid-Positive, Taste, Fever, Headache, Pneumonia, Stomach, Myocarditis, Blood-Clots, Death
symptom_names = {
    'Covid-Recovered': 0,
    'Covid-Positive': 1,
    'Taste': 2,
    'Fever': 3,
    'Headache': 4,
    'Pneumonia': 5,
    'Stomach': 6,
    'Myocarditis': 7,
    'Blood-Clots': 8,
    'Death': 9}

# imports
import numpy as np
import pickle
import matplotlib.pyplot as plt
from sklearn.linear_model import LogisticRegression
from sklearn.linear_model import LogisticRegressionCV # has cross validation in it
from sklearn.linear_model import RidgeClassifierCV
from sklearn.ensemble import RandomForestClassifier
from scipy.stats import bernoulli
from scipy.special import softmax
import copy
from sklearn.model_selection import StratifiedKFold
import sklearn.model_selection
from sklearn.utils import resample
from sklearn.metrics import accuracy_score, f1_score

## A policy for treating individuals.
## 
##
## features: gender, age, income, genes, comorbidities, symptoms
## action: vaccines choice or treatment
## outcomes: symptoms (including covid-positive)

class Policy:
    """ A policy for treatment/vaccination. """
    def __init__(self, n_actions, action_set):
        """ Initialise.
        Args:
        n_actions (int): the number of actions
        action_set (list): the set of actions
        """
        self.n_actions = n_actions
        self.action_set = action_set
        print("Initialising policy with ", n_actions, "actions")
        print("A = {", action_set, "}")
    ## Observe the features, treatments and outcomes of one or more individuals
    def observe(self, features, action, outcomes):
        """Observe features, actions and outcomes.
        Args:
        features (t*|X| array)
        actions (t*|A| array)
        outcomes (t*|Y| array)
        The function is used to adapt a model to the observed
        outcomes, given the actions and features. I suggest you create
        a model that estimates P(y | x,a) and fit it as appropriate.
        If the model cannot be updated incrementally, you can save all
        observed x,a,y triplets in a database and retrain whenever you
        obtain new data.
        Pseudocode:
            self.data.append(features, actions, outcomes)
            self.model.fit(data)
        """
        pass
    def get_utility(self, features, action, outcome):
        """ Obtain the empirical utility of the policy on a set of one or more people. 
        If there are t individuals with x features, and the action
        
        Args:
        features (t*|X| array)
        actions (t*|A| array)
        outcomes (t*|Y| array)
        Returns:
        Empirical utility of the policy on this data.
        """

        return 0
    def get_action(self, features):
        """Get actions for one or more people. 
        Args: 
        features (t*|X| array)
        Returns: 
        actions (t*|A| array)
        Here you should take the action maximising expected utility
        according to your model. This model can be arbitrary, but
        should be adapted using the observe() method.
        Pseudocode:
           for action in appropriate_action_set:
                p = self.model.get_probabilities(features, action)
                u[action] = self.get_expected_utility(action, p)
           return argmax(u)
        You are expected to create whatever helper functions you need.
        """
        return 0

class RandomPolicy(Policy):
    """ This is a purely random policy!"""

    def get_utility(self, features, action, outcome):
        """Here the utiliy is defined in terms of the outcomes obtained only, ignoring both the treatment and the previous condition.
        """
        actions = self.get_action(features)
        utility = 0
        utility -= 0.2 * sum(outcome[:,symptom_names['Covid-Positive']])
        utility -= 0.1 * sum(outcome[:,symptom_names['Taste']])
        utility -= 0.1 * sum(outcome[:,symptom_names['Fever']])
        utility -= 0.1 * sum(outcome[:,symptom_names['Headache']])
        utility -= 0.5 * sum(outcome[:,symptom_names['Pneumonia']])
        utility -= 0.2 * sum(outcome[:,symptom_names['Stomach']])
        utility -= 0.5 * sum(outcome[:,symptom_names['Myocarditis']])
        utility -= 1.0 * sum(outcome[:,symptom_names['Blood-Clots']])
        utility -= 100.0 * sum(outcome[:,symptom_names['Death']])
        return utility

    
    def get_action(self, features):
        """Get a completely random set of actions, but only one for each individual.
        If there is more than one individual, feature has dimensions t*x matrix, otherwise it is an x-size array.
        
        It assumes a finite set of actions.
        Returns:
        A t*|A| array of actions
        """

        n_people = features.shape[0]
        ##print("Acting for ", n_people, "people");
        actions = np.zeros([n_people, self.n_actions])
        for t in range(features.shape[0]):
            action = np.random.choice(self.action_set)
            if (action >= 0):
                actions[t,action] = 1
            
        return actions




class TrueHistoricalPolicy(Policy):
    """ This is a simple policy that vaccinates unvaccinated people using 
    vaccine 3 with probability p (which reflects the portion of 
    available vaccines), and provides some level of differential privacy"""

    def __init__(self, n_actions, action_set):
        """ Initialise.
        Args:
        n_actions (int): the number of actions
        action_set (list): the set of actions
        vaccination_prob (float in [0,1]): probability of vaccinating 
                                            unvaccinated individuals
        epsilon (float in (0,1]): differential privacy parameter"""
        self.vaccination_rate = [0.7, 0.1, 0.1, 0.1]
        self.symptom_importance_covid = np.array([0,0,2,0,0,0,0,100])
        self.symptom_importance_no_covid = np.array([0,0,1,0,0,0,0,100])
        super(TrueHistoricalPolicy, self).__init__(n_actions, action_set)

    def get_utility(self, features, action, outcome):
        """Here the utiliy is defined in terms of the actions and the previous 
        condition, ignoring the outcome.
        """
        utility = 0
        if len(features.shape) > 1:
          past_vaccinated = np.sum(features[:,-3:])
          past_recovered = features[:,0]
          past_covid = features[:,1]
          past_symptoms = features[:,2:10]
          vaccinated = np.sum(action, axis=1)
          curr_covid = np.logical_or(outcome[:,1], outcome[:,0]) # had covid after the vaccine was given
          curr_symptoms = outcome[:,2:]
        else:
          past_vaccinated = np.sum(features[-3:])>=1
          past_recovered = features[0]
          past_covid = features[1]
          past_symptoms = features[2:10]
          vaccinated = np.sum(action)
          curr_covid = outcome[1]==1 or outcome[0]==1 # had covid after the vaccine was given
          curr_symptoms = outcome[2:]

        utility -= np.dot(vaccinated, 2*np.ones(len(vaccinated)))
        utility -= np.dot(np.multiply(vaccinated,past_vaccinated), 50*np.ones(len(vaccinated)))
        utility -= np.dot(np.multiply(vaccinated,past_recovered), 50*np.ones(len(vaccinated)))
        utility -= np.dot(np.multiply(vaccinated,past_covid), 50*np.ones(len(vaccinated)))
        utility -= np.dot(np.multiply(past_covid<1,curr_covid), 10*np.ones(len(vaccinated)))
        utility -= np.dot(np.dot((curr_symptoms - past_symptoms), self.symptom_importance_covid),curr_covid)
        utility -= np.dot(np.dot((curr_symptoms - past_symptoms), self.symptom_importance_no_covid),curr_covid<1)
        return utility

    
    def get_action(self, features):
      """
        If the person is unvaccinated, we will vaccinate with probability 
        vaccination_prob using vaccine 3. Otherwise, we do not vaccinate.
        It assumes a finite set of actions.
        Returns:
        A t*|A| array of actions (t - number of people)
        """
      if len(features.shape) > 1:
        n_people = features.shape[0]
        actions = np.zeros([n_people, self.n_actions])
        for t in range(n_people):
          vaccine = np.random.choice(4, p=self.vaccination_rate) - 1
          if (vaccine>=0):
            actions[t, vaccine] = 1
      else:
        actions = np.zeros((1,self.n_actions))
        vaccine = np.random.choice(4, p=self.vaccination_rate) - 1
        if (vaccine>=0):
          actions[0, vaccine] = 1
      return actions



class EstimatedHistoricalPolicy(Policy):
    """ This is a simple policy that vaccinates unvaccinated people using 
    vaccine 3 with probability p (which reflects the portion of 
    available vaccines), and provides some level of differential privacy"""

    def __init__(self, n_actions, action_set, model=None):
        """ Initialise.
        Args:
        n_actions (int): the number of actions
        action_set (list): the set of actions
        vaccination_prob (float in [0,1]): probability of vaccinating 
                                            unvaccinated individuals
        epsilon (float in (0,1]): differential privacy parameter"""
        if model is None:
          self.model = LogisticRegressionCV(random_state=0, multi_class='multinomial')
        else:
          self.model = model
        self.symptom_importance_covid = np.array([0,0,2,0,0,0,0,100])
        self.symptom_importance_no_covid = np.array([0,0,1,0,0,0,0,100])
        super(EstimatedHistoricalPolicy, self).__init__(n_actions, action_set)

    def get_utility(self, features, action, outcome):
        # copy the final utility here
        """Here the utiliy is defined in terms of the actions and the previous 
        condition, ignoring the outcome.
        """
        utility = 0
        if len(features.shape) > 1:
          past_vaccinated = np.sum(features[:,-3:])
          past_recovered = features[:,0]
          past_covid = features[:,1]
          past_symptoms = features[:,2:10]
          vaccinated = np.sum(action, axis=1)
          curr_covid = np.logical_or(outcome[:,1], outcome[:,0]) # had covid after the vaccine was given
          curr_symptoms = outcome[:,2:]
        else:
          past_vaccinated = np.sum(features[-3:])>=1
          past_recovered = features[0]
          past_covid = features[1]
          past_symptoms = features[2:10]
          vaccinated = np.sum(action)
          curr_covid = outcome[1]==1 or outcome[0]==1 # had covid after the vaccine was given
          curr_symptoms = outcome[2:]

        utility -= np.dot(vaccinated, 2*np.ones(len(vaccinated)))
        utility -= np.dot(np.multiply(vaccinated,past_vaccinated), 50*np.ones(len(vaccinated)))
        utility -= np.dot(np.multiply(vaccinated,past_recovered), 50*np.ones(len(vaccinated)))
        utility -= np.dot(np.multiply(vaccinated,past_covid), 50*np.ones(len(vaccinated)))
        utility -= np.dot(np.multiply(past_covid<1,curr_covid), 10*np.ones(len(vaccinated)))
        utility -= np.dot(np.dot((curr_symptoms - past_symptoms), self.symptom_importance_covid),curr_covid)
        utility -= np.dot(np.dot((curr_symptoms - past_symptoms), self.symptom_importance_no_covid),curr_covid<1)
        return utility
    



    def observe(self, features, action, outcomes, balance=True):
      targets = np.zeros(features.shape[0])
      for i in range(len(features)):
        if np.sum(action[i]) >= 1:
          targets[i] = np.argmax(action[i])
        else:
          targets[i] = 3
      #targets = np.zeros((features.shape[0], self.n_actions+1))
      #targets[:,-3:] = action
      #targets[:,0] = 1 - np.sum(action, axis=1)
      if balance:
        unvaccinated_ind = np.sum(action, axis=1)<1
        vacc_ind = np.sum(action, axis=1) >= 1
        sample_features, sample_labels = bootstrap_sampling(features[unvaccinated_ind,:], targets[unvaccinated_ind], n_samples=int(len(features)/3)) # under sampling
        sample_features_pos, sample_labels_pos = features[vacc_ind,:], targets[vacc_ind]
      features = np.concatenate((sample_features, sample_features_pos), axis=0)
      targets = np.concatenate((sample_labels, sample_labels_pos), axis=0)  
      self.model.fit(features, targets)
      print(self.model.score(features, targets))

    
    def get_action(self, features):
      """
        If the person is unvaccinated, we will vaccinate with probability 
        vaccination_prob using vaccine 3. Otherwise, we do not vaccinate.
        It assumes a finite set of actions.
        Returns:
        A t*|A| array of actions (t - number of people)
        """
      if len(features.shape) > 1:
        n_people = features.shape[0]
        actions = np.zeros([n_people, self.n_actions])
        for t in range(n_people):
          vaccine = self.model.predict(features[t].reshape((1,len(features[t]))))[0]
          #print(vaccine)
          if vaccine < 3:
          #prob = self.model.predict(features[t,:-3])
          #vaccine = np.random.choice(4, p=prob) - 1
          #if (vaccine>=0):
            actions[t, vaccine] = 1
      else:
        actions = np.zeros((1,self.n_actions))
        vaccine = self.model.predict(features.reshape((1,len(features))))[0]
        #vaccine = np.random.choice(4, p=prob) - 1
        if (vaccine<3):
          actions[0, vaccine] = 1
      return actions



class SimplePolicy(Policy):
    """ This is a simple policy that vaccinates unvaccinated people using 
    vaccine 3 with probability p (which reflects the portion of 
    available vaccines), and provides some level of differential privacy"""

    def __init__(self, n_actions, action_set, vaccination_prob, epsilon):
        """ Initialise.
        Args:
        n_actions (int): the number of actions
        action_set (list): the set of actions
        vaccination_prob (float in [0,1]): probability of vaccinating 
                                            unvaccinated individuals
        epsilon (float in (0,1]): differential privacy parameter"""
        self.vaccination_prob = vaccination_prob
        self.epsilon = epsilon
        super(SimplePolicy, self).__init__(n_actions, action_set)

    def get_utility(self, features, action, outcome):
        """Here the utiliy is defined in terms of the actions and the previous 
        condition, ignoring the outcome.
        """
        actions = self.get_action(features)
        utility = 0
        if len(features.shape) > 1:
          vaccinated = np.sum(features[:,-3:], axis=1)
        else:
          vaccinated = np.sum(features[-3:])
          #actions.reshape((1, len(actions)))
        
        # decrease utility if we vaccinate people who are already vaccinated
        utility -= np.sum(np.multiply(vaccinated>0, actions[:,-1]>0))
        
        # increase utility if we vaccinate unvaccinated people
        utility += np.sum(np.multiply(vaccinated==0, actions[:,-1]>0))

        # decrease utility if we do not vaccinate unvaccinated people 
        utility -= 0.1 * np.sum(np.multiply(vaccinated==0, actions[:,-1]==0))
        return utility
    
        

    def get_action(self, features):
      """
        If the person is unvaccinated, we will vaccinate with probability 
        vaccination_prob using vaccine 3. Otherwise, we do not vaccinate.
        It assumes a finite set of actions.
        Returns:
        A t*|A| array of actions (t - number of people)
        """
      if len(features.shape) > 1:
        n_people = features.shape[0]
        actions = np.zeros([n_people, self.n_actions])
        for t in range(n_people):
            if np.sum(features[t,-3:]) == 0:
              actions[t,-1] = np.random.binomial(1, self.vaccination_prob)
        actions[:,-1] += np.random.laplace(scale = 1 / self.epsilon, size=len(actions[:,-1]))
        actions[:,-1] = np.clip(actions[:,-1], 0, 1)
      else:
        actions = np.zeros((1,self.n_actions))
        if np.sum(features[-3:]) == 0:
              actions[0,-1] = np.random.binomial(1, self.vaccination_prob)
        actions[0,-1] += np.random.laplace(scale = 1 / self.epsilon)
        actions[0,-1] = np.clip(actions[0,-1], 0, 1)
      return actions


# helper functions
def kfold_cross_validation(data_features, data_labels, params, k=5):
  skf = StratifiedKFold(n_splits=k)
  n_params = len(params)
  validation_res = np.zeros(n_params)
  for i in range(n_params):
    for train_index, test_index in skf.split(data_features, data_labels):
        X_train, X_test = data_features[train_index], data_features[test_index]
        y_train, y_test = data_labels[train_index], data_labels[test_index]
        validation_res[i] += evaluate_f1(LogisticRegression(penalty='l1', C=params[i], solver='liblinear', random_state=0), X_train, y_train, X_test, y_test)
  return validation_res/k

# pipeline for train-test split, k-fold cross validation, evaluation on test set
# returns a model trained on the entire dataset (including the test)
def training_pipeline(data_features, data_labels, params):
  X_train, X_test, y_train, y_test = sklearn.model_selection.train_test_split(data_features, data_labels)
  validation_res = kfold_cross_validation(X_train, y_train, params, k=5)
  best_param = params[np.argmax(validation_res)]
  clf = LogisticRegression(penalty='l1', C=best_param, solver='liblinear', random_state=0)
  clf.fit(data_features, data_labels)
  return clf

# resampling function
def bootstrap_sampling(data_features, data_labels, n_samples=None):
    if n_samples is None:
      n_samples = len(data_labels)
    all_data = np.concatenate((data_features, np.array([data_labels]).T), axis=1)
    sample = resample(all_data, n_samples=n_samples, random_state=None, stratify=None)
    return sample[:,:-1], sample[:,-1]

def evaluate_f1(clf, X_train, y_train, X_test, y_test):
    clf.fit(X_train, y_train)
    y_pred = clf.predict(X_test)
    return f1_score(y_pred, y_test)


class ImprovedPolicy(Policy):
    """ This is a simple policy that vaccinates unvaccinated people using 
    vaccine 3 with probability p (which reflects the portion of 
    available vaccines), and provides some level of differential privacy"""

    def __init__(self, n_actions, action_set, epsilon, n_samples=10, models=None):
        """ Initialise.
        Args:
        n_actions (int): the number of actions
        action_set (list): the set of actions
        epsilon (float in (0,1]): differential privacy parameter"""
        self.epsilon = epsilon
        self.n_samples = n_samples
        #X = pop[:,10:]
        #Y = pop[:,:10]
        #A = pop[:,-3:]
        #self.clf = LogisticRegression(warm_start=True, random_state=0).fit(np.concatenate((X, A),axis=1), Y)
        if models is None:
          #self.model = RidgeClassifierCV(cv=5)
          self.models = []
        else:
          self.models = models
        #self.sample_size = sample_size
        #self.action_vecs = np.eye(n_actions)
        self.symptom_importance_covid = np.array([0,0,2,0,0,0,0,100])
        self.symptom_importance_no_covid = np.array([0,0,1,0,0,0,0,100])
        super(ImprovedPolicy, self).__init__(n_actions, action_set)


    def observe(self, features, action, outcomes):
      # if len(features.shape) > 1:
      #   X = np.concatenate([features[:,10:], action], axis=1)
      # else:
      #   X = np.concatenate([features[10:], action])
      train_features = np.zeros((features.shape[0], features.shape[1]+self.n_actions+1))
      train_features[:,:-4] = features
      train_features[:,-3:] = action
      train_features[:,-4] = np.ones(features.shape[0]) - np.sum(action, axis=1)
      minimal_symptoms = np.zeros((features.shape[0], 3))
      minimal_symptoms[:,0] = outcomes[:,1] # covid
      minimal_symptoms[:,1] = outcomes[:,-1] # death
      minimal_symptoms[:,2] = np.sum(outcomes[:,2:-1], axis=1) > 0 # other symptom
      for i in range(len(minimal_symptoms[0])):
        symptom = minimal_symptoms[:,i]
        positive_ind = symptom==1
        negative_ind = symptom==0
        print(negative_ind.shape)
        print(symptom.shape)
        print(train_features.shape)
        if np.sum(positive_ind) / (np.sum(negative_ind) + np.sum(positive_ind)) < 0.6:
          ratio = (np.sum(negative_ind) / np.sum(positive_ind)) / 2
          sample_features_neg, sample_labels_neg = bootstrap_sampling(train_features[negative_ind,:], symptom[negative_ind], n_samples=int(len(features)/2)) # under sampling
          sample_features_pos, sample_labels_pos = bootstrap_sampling(train_features[positive_ind,:], symptom[positive_ind], n_samples=int(len(features)*ratio)) # over sampling
          curr_train_features = np.concatenate((sample_features_neg, sample_features_pos), axis=0)
          symptom = np.concatenate((sample_labels_neg, sample_labels_pos), axis=0)
        model = training_pipeline(curr_train_features, symptom, [0.001, 0.01, 0.1, 0.5, 1, 1.5, 2, 5])
        print(model.score(curr_train_features, symptom))
        self.models.append(model)
      

    def get_individual_utility(self, features, action, outcomes):
      utility = 0
      past_vaccinated = np.sum(features[-3:])>=1
      past_recovered = features[0] == 1
      past_covid = features[1] == 1
      past_symptoms = features[2:10]
      vaccinated = np.sum(action) >= 1
      curr_covid = outcomes[1]==1 or outcomes[0]==1 # had covid after the vaccine was given
      curr_symptoms = outcomes[2:]

      if vaccinated:
        utility -= 10
        if past_vaccinated:
          utility -= 50 # we don't want to vaccinate vaccinated people
        if past_recovered:
          utility -= 50 # we don't want to vaccinate recovered people
        if past_covid:
          utility -= 50 # we don't want to vaccinate sick people
      if not past_covid and curr_covid: # got covid
        utility -= 10
      if curr_covid:
        utility -= np.dot((curr_symptoms - past_symptoms), self.symptom_importance_covid)
      if not curr_covid:
        utility -= np.dot((curr_symptoms - past_symptoms), self.symptom_importance_no_covid)
      return utility


    def get_element_utility(self, features, action, outcome):
        """Here the utiliy is defined in terms of the actions and the previous 
        condition, ignoring the outcome.
        """
        utility = np.zeros(features.shape[0])
        past_vaccinated = np.sum(features[:,-3:], axis=1)
        past_recovered = features[:,0]
        past_covid = features[:,1]
        past_symptoms = features[:,2:10]
        vaccinated = np.sum(action, axis=1)
        curr_covid = np.logical_or(outcome[:,1], outcome[:,0]) # had covid after the vaccine was given
        curr_symptoms = outcome[:,2:]
        utility -= np.multiply(vaccinated, 2*np.ones(len(vaccinated)))
        utility -= np.multiply(np.multiply(vaccinated,past_vaccinated), 50*np.ones(len(vaccinated)))
        utility -= np.multiply(np.multiply(vaccinated,past_recovered), 50*np.ones(len(vaccinated)))
        utility -= np.multiply(np.multiply(vaccinated,past_covid), 50*np.ones(len(vaccinated)))
        utility -= np.multiply(np.multiply(past_covid<1,curr_covid), 10*np.ones(len(vaccinated)))
        utility -= np.multiply(np.dot((curr_symptoms - past_symptoms), self.symptom_importance_covid),curr_covid)
        utility -= np.multiply(np.dot((curr_symptoms - past_symptoms), self.symptom_importance_no_covid),curr_covid<1)
        return utility




        def get_utility(self, features, action, outcome):
          """Here the utiliy is defined in terms of the actions and the previous 
          condition, ignoring the outcome.
          """
          # utility = 0
          # if len(features.shape) > 1:
          #   past_vaccinated = np.sum(features[:,-3:], axis=1)
          #   past_recovered = features[:,0]
          #   past_covid = features[:,1]
          #   past_symptoms = features[:,2:10]
          #   vaccinated = np.sum(action, axis=1)
          #   curr_covid = np.logical_or(outcome[:,1], outcome[:,0]) # had covid after the vaccine was given
          #   curr_symptoms = outcome[:,2:]  
          #   utility -= np.dot(vaccinated, 2*np.ones(len(vaccinated)))
          #   utility -= np.dot(np.multiply(vaccinated,past_vaccinated), 50*np.ones(len(vaccinated)))
          #   utility -= np.dot(np.multiply(vaccinated,past_recovered), 50*np.ones(len(vaccinated)))
          #   utility -= np.dot(np.multiply(vaccinated,past_covid), 50*np.ones(len(vaccinated)))
          #   utility -= np.dot(np.multiply(past_covid<1,curr_covid), 10*np.ones(len(vaccinated)))
          #   utility -= np.dot(np.dot((curr_symptoms - past_symptoms), self.symptom_importance_covid),curr_covid)
          #   utility -= np.dot(np.dot((curr_symptoms - past_symptoms), self.symptom_importance_no_covid),curr_covid<1)
          # else:
          #   utility = self.get_individual_utility(features, action, outcome)
          # return utility
          utility = 0
          print("here")
          if len(features.shape) > 1:
            past_vaccinated = np.sum(features[:,-3:])
            past_recovered = features[:,0]
            past_covid = features[:,1]
            past_symptoms = features[:,2:10]
            vaccinated = np.sum(action, axis=1)
            curr_covid = np.logical_or(outcome[:,1], outcome[:,0]) # had covid after the vaccine was given
            curr_symptoms = outcome[:,2:]
          else:
            past_vaccinated = np.sum(features[-3:])>=1
            past_recovered = features[0]
            past_covid = features[1]
            past_symptoms = features[2:10]
            vaccinated = np.sum(action)
            curr_covid = outcome[1]==1 or outcome[0]==1 # had covid after the vaccine was given
            curr_symptoms = outcome[2:]

          utility -= np.dot(vaccinated, 2*np.ones(len(vaccinated)))
          print(utility)
          utility -= np.dot(np.multiply(vaccinated,past_vaccinated), 50*np.ones(len(vaccinated)))
          print(utility)
          utility -= np.dot(np.multiply(vaccinated,past_recovered), 50*np.ones(len(vaccinated)))
          print(utility)
          utility -= np.dot(np.multiply(vaccinated,past_covid), 50*np.ones(len(vaccinated)))
          print(utility)
          utility -= np.dot(np.multiply(past_covid<1,curr_covid), 10*np.ones(len(vaccinated)))
          print(utility)
          utility -= np.dot(np.dot((curr_symptoms - past_symptoms), self.symptom_importance_covid),curr_covid)
          print(utility)
          utility -= np.dot(np.dot((curr_symptoms - past_symptoms), self.symptom_importance_no_covid),curr_covid<1)
          print(utility)
          return utility

    
    def predict_individual_outcome(self, features, action):
      s_features = np.zeros((1, len(features)+self.n_actions+1))
      s_features[0,:-4] = features
      #s_features[0,-3:] = features[:,-3:] # including the actions
      s_features[0,-3:] = action
      if sum(action) == 0:
        s_features[:,-4] = 1
      #return self.model.predict(s_features)
      p = np.array([model.predict_proba(s_features)[0][1] for model in self.models])
      #p = np.array([a[0][1] for a in self.model.predict_proba(s_features)])
      outcomes = np.zeros(10)
      map_to_ind = [1,-1,4]
      for symptom in range(3):
        outcomes[map_to_ind[symptom]] = np.random.binomial(1, p[symptom])
      return outcomes
      


    def predict_outcomes(self, features, action):
      s_features = np.zeros((features.shape[0], features.shape[1]+self.n_actions+1))
      s_features[:,:-4] = features
      #s_features[0,-3:] = features[:,-3:] # including the actions
      s_features[:,-3:] = action
      s_features[:,-4] = np.ones(features.shape[0]) - np.sum(action, axis=1)
      predictions = np.zeros((features.shape[0], 10))
      map_to_ind = [1,-1,4]
      for i in range(3):
        predictions[:,map_to_ind[i]] = self.models[i].predict_proba(s_features)[0][1]
      return predictions

        
    def get_individual_action(self, features):
      U = np.zeros(self.n_actions+1)
      for i in range(self.n_actions):
        A = np.zeros(self.n_actions)
        if i == 0:
          for it in range(self.n_samples):
            Y = self.predict_individual_outcome(features, A)
            U[0] += self.get_utility(features, A, Y)
          U[0] /= self.n_samples
        A[i] = 1
        for it in range(self.n_samples):
          Y = self.predict_individual_outcome(features, A)
          U[i+1] += self.get_utility(features, A, Y)
        U[i+1] /= self.n_samples
        #for j in range(self.sample_size):
         # Y = np.random.binomial(1, self.clf.predict_proba(X))
          #U[i] += self.get_utility(features, self.action_vecs[i]], Y)
      #U /= self.sample_size
      action_prob = softmax(U)
      action = np.random.choice(4, p=action_prob) - 1
      action_array = np.zeros((1,self.n_actions))
      if (action>=0):
        action_array[0,action] = 1
      # add laplace noise
      # action_array[0,-1] += np.random.laplace(scale = 1 / self.epsilon)
      # action_array[0,-1] = np.clip(action_array[0,-1], 0, 1)
      return action_array   
        

    def get_action(self, features):
      """
        If the person is unvaccinated, we will vaccinate with probability 
        vaccination_prob using vaccine 3. Otherwise, we do not vaccinate.
        It assumes a finite set of actions.
        Returns:
        A t*|A| array of actions (t - number of people)
        """
      # if len(features.shape) > 1:
      #   U = np.zeros((features.shape[0], self.n_actions+1))
      #   for i in range(self.n_actions):
      #     action = np.zeros(self.n_actions)
      #     action[i] = 1
      #     curr_actions = np.tile(action, [len(features),1])
      #     Y = self.predict_outcomes(features, curr_actions)
      print("here")
      if len(features.shape) > 1:
        n_people = features.shape[0]
        actions = np.zeros([n_people, self.n_actions])
        U = np.zeros((n_people, self.n_actions+1))
        #results[i,0] = model.predict_proba([np.concatenate((data[val], np.array([0,0])))])[0][1]
        for i in range(self.n_actions):
          A = np.zeros((n_people, self.n_actions))
          if i == 0:
            Y = self.predict_outcomes(features, A)
            U[:,0] = self.get_element_utility(features, A, Y)
          A[:,i] = np.ones(n_people)
          Y = self.predict_outcomes(features, A)
          U[:,i+1] = self.get_element_utility(features, A, Y)
        action_prob = softmax(U, axis=1)
        for t in range(n_people):
          #action = np.random.choice(4, p=action_prob[t]) - 1
          action = np.argmax(U[t]) - 1
          if (action>=0):
            actions[t,action] = 1
        for j in range(actions.shape[1]):
          actions[:,j] += np.random.laplace(scale = 1 / self.epsilon, size=len(actions[:,j]))
          actions[:,j] = np.clip(actions[:,j], 0, 1)
      else:
        actions = np.zeros((1,self.n_actions))
        actions[0,:] = self.get_individual_action(features) 
        for j in range(actions.shape[1]):
          actions[0,j] += np.random.laplace(scale = 1 / self.epsilon)
          actions[0,j] = np.clip(actions[0,j], 0, 1)             
      return actions

## Comborbidities: 
## Asthma, Obesity,  Smoking, Diabetes, Heart diseae, Hypertension
## Symptom list: Covid-Recovered, Covid-Positive, Taste, Fever, Headache, Pneumonia, Stomach, Myocarditis, Blood-Clots, Death
## Mild symptoms: Taste, Fever, Headache, Stomach
## Critical symptoms: Pneumonia, Myocarditis, Blood-Clots

class Person:
    def __init__(self, pop):
        self.genes = np.random.choice(2, size=pop.n_genes)
        self.gender = np.random.choice(2)
        self.age = np.random.gamma(3,11)
        self.age_adj = self.age/100 # age affects everything
        self.income = np.random.gamma(1,10000)
        self.comorbidities=[0] * pop.n_comorbidities
        self.comorbidities[0] = pop.asthma
        self.comorbidities[1] = pop.obesity*self.age_adj
        self.comorbidities[2] = pop.smoking
        self.diab = pop.diabetes + self.comorbidities[1]*0.5
        self.HT = pop.htension + self.comorbidities[2]*0.5
        self.comorbidities[3] = self.diab
        self.comorbidities[4] = pop.heart*self.age_adj
        self.comorbidities[5] = self.HT*self.age_adj
    
        for i in range(pop.n_comorbidities):
            if (np.random.uniform() < self.comorbidities[i]):
                self.comorbidities[i] = 1
            else:
                self.comorbidities[i] = 0

        self.symptom_baseline = np.array([pop.historical_prevalence, pop.prevalence, 0.01, 0.05, 0.05, 0.01, 0.02, 0.001, 0.001, 0.001]);
        self.symptom_baseline = np.array(np.matrix(self.genes) * pop.G).flatten() * self.symptom_baseline
        self.symptom_baseline[0] = pop.historical_prevalence;
        self.symptom_baseline[1] = pop.prevalence;
        if (self.gender==1):
            self.symptom_baseline[8] += 0.01
        else:
            self.symptom_baseline[7] += 0.01
            self.symptom_baseline[9] += 0.01

        # Initially no symptoms apart from Covid+/CovidPre
        self.symptoms = [0] * pop.n_symptoms
        if (np.random.uniform() <= self.symptom_baseline[0]):
            self.symptoms[0] = 1

        # increase symptom probabilities for symptoms when covid+
        if (np.random.uniform() <= self.symptom_baseline[1]):
            self.symptoms[1] = 1
            self.symptom_baseline = np.array([pop.historical_prevalence, pop.prevalence, 0.3, 0.2, 0.05, 0.2, 0.02, 0.05, 0.2, 0.1]);

        self.vaccines=[0] * pop.n_vaccines

    # use vaccine = -1 if no vaccine is given
    def vaccinate(self, vaccine_array, pop):
        ## Vaccinated
        if (sum(vaccine_array) >=0 ):
            vaccinated = True
        else:
            vaccinated = False
            
        if (vaccinated):
            vaccine = np.argmax(vaccine_array)
            self.vaccines = vaccine_array
            self.symptom_baseline[1] *= pop.baseline_efficacy[vaccine]
        else:
          vaccine = -1


        if (vaccinated and self.symptoms[1]==1):
            self.symptom_baseline[[2,3,4,6]] *= pop.mild_efficacy[vaccine]
            self.symptom_baseline[[5,7,8]] *= pop.critical_efficacy[vaccine]
            self.symptom_baseline[9] *= pop.death_efficacy[vaccine]

        if (self.symptoms[0]==1):
            self.symptom_baseline*=0.5

        # baseline symptoms of non-covid patients
        if (self.symptoms[0]==0 and self.symptoms[1]==0):
            self.symptom_baseline = np.array([0, 0, 0.001, 0.01, 0.02, 0.002, 0.005, 0.001, 0.002, 0.0001]);
            ## Common side-effects
            if (vaccine==1):
                self.symptom_baseline[8]+=0.01
                self.symptom_baseline[9]+=0.001
            if (vaccine==2):
                self.symptom_baseline[7]+=0.01
            if (vaccine>=0):
                self.symptom_baseline[3]+=0.2
                self.symptom_baseline[4]+=0.1

        # model long covid sufferers by increasing the chances of various symptoms slightly
        if (self.symptoms[0]==1 and self.symptoms[1]==0):
            self.symptom_baseline += np.array([0, 0, 0.06, 0.04, 0.01, 0.04, 0.004, 0.01, 0.04, 0.01]);

        # genetic factors
        self.symptom_baseline = np.array(np.matrix(self.genes) * pop.G).flatten() * self.symptom_baseline
        #print("V:", vaccine, symptom_baseline)
        for s in range(2,pop.n_symptoms):
            if (np.random.uniform() < self.symptom_baseline[s]):
                self.symptoms[s] = 1

class Population:
    def __init__(self, n_genes, n_vaccines, n_treatments):
        self.n_genes = n_genes
        self.n_comorbidities = 6;
        self.n_symptoms = 10
        self.n_vaccines = n_vaccines
        self.n_treatments = n_treatments
        self.G = np.random.uniform(size=[self.n_genes, self.n_symptoms])
        self.G /= sum(self.G)
        self.A = np.random.uniform(size=[self.n_treatments, self.n_symptoms])
        self.asthma = 0.08
        self.obesity = 0.3
        self.smoking = 0.2
        self.diabetes = 0.1
        self.heart = 0.15
        self.htension = 0.3
        self.baseline_efficacy=[0.5, 0.6, 0.7]
        self.mild_efficacy=[0.6, 0.7, 0.8]
        self.critical_efficacy=[0.8, 0.75, 0.85]
        self.death_efficacy=[0.9, 0.95, 0.9]
        self.vaccination_rate = [0.7, 0.1, 0.1, 0.1]
        self.prevalence = 0.1
        self.historical_prevalence=0.1
        


        
    ## Generates data with the following structure:
    ## X: characteristics before treatment, including whether or not they were vaccinated 
    ## The generated population may already be vaccinated.
    def generate(self, n_individuals):
        """Generate a population. 
        Call this function before anything else is done. 
        Calling this function again generates a completely new population sample, purging the previous one from memory.
        :param int n_individuals: the number of individuals to generate
        """
        self.n_individuals = n_individuals
        X = np.zeros([n_individuals, 3 + self.n_genes + self.n_comorbidities + self.n_vaccines + self.n_symptoms])
        Y = np.zeros([n_individuals, self.n_treatments, self.n_symptoms])
        self.persons = []
        for t in range(n_individuals):
            person = Person(self)
            vaccine = np.random.choice(4, p=self.vaccination_rate) - 1
            vaccine_array = np.zeros(self.n_vaccines)
            
            if (vaccine>=0):
                vaccine_array[vaccine] = 1
            person.vaccinate(vaccine_array, self)
            self.persons.append(person)
            x_t = np.concatenate([person.symptoms, [person.age, person.gender, person.income], person.genes, person.comorbidities, person.vaccines])
            X[t,:] = x_t
        self.X = X
        return X

    def vaccinate(self, person_index, vaccine_array):
        """ Give a vaccine to a specific person.
        Args:
        person_index (int array), indices of person in the population
        vaccine_array (n*|A| array), array indicating which vaccines are to be given to each patient
        Returns:
        The symptoms of the selected individuals 
        
        Notes:
        Currently only one vaccine dose is implemented, but in the future multiple doses may be modelled.
        """
        outcome = np.zeros([len(person_index), self.n_symptoms])
        i = 0
        for t in person_index:
            self.persons[t].vaccinate(vaccine_array[i], self)
            outcome[i] = self.persons[i].symptoms
            i+=1
        return outcome
    
    def treat(self, person_index, treatment):
        """ Treat a patient.
        Args:
        person_index (int array), indices of persons in the population to treat
        treatment_array (n*|A| array), array indicating which treatments are to be given to each patient
        Returns:
        The symptoms of the selected individuals 
        """

        N = len(person_index)
        result = np.zeros([N, self.n_symptoms])
        # use i to index the treated
        # use t to index the original population
        #print(treatment)
        for i in range(N):
            t = person_index[i]
            r = np.array(np.matrix(treatment[i]) * self.A).flatten()
            for k in range(self.n_symptoms):
                if (k <= 1):
                    result[i, k] = self.X[t, k]
                else:
                    if (np.random.uniform() < r[k]):
                        result[i, k] = 0
                    else:
                        result[i, k] = self.X[t, k]
        return result

    def get_features(self, person_index):
        x_t = np.concatenate([self.persons[t].symptoms, [self.persons[t].age, self.persons[t].gender, self.persons[t].income], self.persons[t].genes, self.persons[t].comorbidities, self.persons[t].vaccines])
        return x_t
    
    ## Treats a population
    def treatment(self, X, policy):
        treatments = np.zeros([X.shape[0], self.n_treatments])
        result = np.zeros([X.shape[0], self.n_symptoms])
        for t in range(X.shape[0]):
            #print ("X:", result[t])
            treatments[t] = policy.get_action(X[t].reshape(1,-1))
            r = np.array(np.matrix(treatments[t]) * self.A).flatten()
            for k in range(self.n_symptoms):
                if (k <= 1):
                    result[t,k] = X[t,k]
                else:
                    if (np.random.uniform() < r[k]):
                        result[t,k] = 0
                    else:
                        result[t,k] = X[t,k]
            ##print("X:", X[t,:self.n_symptoms] , "Y:",  result[t])  
        return treatments, result

    
# main
#if __name__ == "__main__":
def main():
    import pandas
    import policy
    n_symptoms = 10
    n_genes = 128
    n_vaccines = 3
    n_treatments = 4
    pop=Population(n_genes, n_vaccines, n_treatments)
    n_observations = 1000
    X_observation = pop.generate(n_observations)
    pandas.DataFrame(X_observation).to_csv('observation_features.csv', header=False, index=False)
    n_treated = 1000
    X_treatment = pop.generate(n_treated)
    X_treatment = X_treatment[X_treatment[:,1]==1]
    print("Generating treatment outcomes")
    a, y = pop.treatment(X_treatment, policy.RandomPolicy(n_treatments, list(range(n_treatments))))
    pandas.DataFrame(X_treatment).to_csv('treatment_features.csv', header=False, index=False)
    pandas.DataFrame(a).to_csv('treatment_actions.csv', header=False, index=False)
    pandas.DataFrame(y).to_csv('treatment_outcomes.csv', header=False, index=False)

## Baseline simulator parameters
n_genes = 128
n_vaccines = 3
n_treatments = 4
n_population = 10000

# symptom names for easy reference


# Create the underlying population
print("Generating population")
population = Population(n_genes, n_vaccines, n_treatments)
X = population.generate(n_population)

# Make sure that your policy appropriately filters out the population if necessary. This is just a random sample of 1000 people


# Generate vaccination results

print("Vaccination")
vaccine_policy = RandomPolicy(n_vaccines, list(range(-1,n_vaccines))) # make sure to add -1 for 'no vaccine'


print("With a for loop")
# The simplest way to work is to go through every individual in the population
for t in range(n_population):
    a_t = vaccine_policy.get_action(X[t])
    # Then you can obtain results for everybody
    y_t = population.vaccinate([t], a_t)
    # Feed the results back in your policy. This allows you to fit the
    # statistical model you have.
    vaccine_policy.observe(X[t], a_t, y_t)

print("Vaccinate'em all")
# Here you can get an action for everybody in the population
A = vaccine_policy.get_action(X)
# Then you can obtain results for everybody
Y = population.vaccinate(list(range(n_population)), A)
# Feed the results back in your policy. 
vaccine_policy.observe(X, A, Y)



# You can do the same iteratively, where you select some to treat, and the rest remain untreated. The following implements a 3-phase vaccination policy.
print("3-phase policy")
for k in range(3):
    A = vaccine_policy.get_action(X)
    # Then you can obtain results for everybody
    Y = population.vaccinate(list(range(n_population)), A)
    # Feed the results back in your policy
    vaccine_policy.observe(X, A, Y)

   

# We can do the same for treatments
print("Treatment")
treatment_policy = RandomPolicy(n_treatments, list(range(n_treatments)))

A = treatment_policy.get_action(X)
Y = population.treat(list(range(n_population)), A)
treatment_policy.observe(X, A, Y)

# estimate the historical policy based on historical data

# # could add k-fold cross validation
# def estimate_historical_policy(X, A):
#   #features = X[:,10:-3] # with symptomes
#   targets = np.zeros((X.shape[0], self.n_actions+1))
#   targets[:,-3:] = X[:,-3:]
#   targets[:,0] = 1 - np.sum(X[:,-3:], axis=1)
#   clf = LogisticRegressionCV(random_state=0, multi_class=”multinomial”)
#   clf.fit(X, targets)
#   print(clf.score(X, targets))
#   return clf

# improved policy

# predict outcomes based on features and actions

# # could add k-fold cross validation
# def predict_outcomes(X):
#   features = np.zeros((X.shape[0], X.shape[1]+1))
#   features[:,:-1] = X[:,10:] # without symptomes, including the actions
#   features[:,-1] = np.ones(X.shape[0]) - np.sum(features[:,-3:], axis=1)
#   targets = X[:,:10]
#   clf = RidgeClassifierCV(cv=5)
#   clf.fit(features, targets)
#   print(clf.score(features, targets))
#   return clf

# utility of the historical and improved policies on the historical data

def get_utility(X, population, policy):
  A = policy.get_action(X)
  Y = population.vaccinate(list(range(n_population)), A)
  return policy.get_utility(X, A, Y)

## Baseline simulator parameters
n_genes = 128
n_vaccines = 3
n_treatments = 4
n_population = 1000


#print("Generating vaccinated population")
#population = Population(n_genes, n_vaccines, n_treatments)
#X_vac = population.generate(n_population)

# Create the underlying population
print("Generating unvaccinated population")
population = Population(n_genes, n_vaccines, n_treatments)
population.vaccination_rate = [1,0,0,0]
X = population.generate(n_population)
X_copy1 = copy.deepcopy(X)
X_copy2 = copy.deepcopy(X)
X_copy3 = copy.deepcopy(X)
# population1 = Population(n_genes, n_vaccines, n_treatments)
# population2 = Population(n_genes, n_vaccines, n_treatments)
# population3 = Population(n_genes, n_vaccines, n_treatments)
# population1.X = copy.deepcopy(X)
# population2.X = copy.deepcopy(X)
# population3.X = copy.deepcopy(X)
# population1.persons = copy.deepcopy(population.persons)
# population2.persons = copy.deepcopy(population.persons)
# population2.persons = copy.deepcopy(population.persons)

population1 = copy.deepcopy(population)
population2 = copy.deepcopy(population)
population3 = copy.deepcopy(population)
population1.X = copy.deepcopy(population.X)
population2.X = copy.deepcopy(population.X)
population3.X = copy.deepcopy(population.X)
population1.persons = copy.deepcopy(population.persons)
population2.persons = copy.deepcopy(population.persons)
population3.persons = copy.deepcopy(population.persons)

true_hist_policy = TrueHistoricalPolicy(n_vaccines, list(range(-1,n_vaccines)))
A = true_hist_policy.get_action(X_copy1)
Y = population1.vaccinate(list(range(n_population)), A)
print("Utility of True Historical Policy: " + str(true_hist_policy.get_utility(X_copy1, A, Y)))


#clf_hist = estimate_historical_policy(X_copy2, A)
#est_hist_policy = EstimatedHistoricalPolicy(n_vaccines, list(range(-1,n_vaccines)), clf_hist)
est_hist_policy = EstimatedHistoricalPolicy(n_vaccines, list(range(-1,n_vaccines)))
est_hist_policy.observe(X_copy2, A, Y)
A2 = est_hist_policy.get_action(X_copy2)
Y2 = population2.vaccinate(list(range(n_population)), A2)
print("Utility of Estimated Historical Policy: " + str(est_hist_policy.get_utility(X_copy2, A2, Y2)))

imp_policy = ImprovedPolicy(n_vaccines, list(range(-1,n_vaccines)), epsilon=0.99, n_samples=1)
imp_policy.observe(X_copy3, A, Y)

models = imp_policy.models

imp_policy = ImprovedPolicy(n_vaccines, list(range(-1,n_vaccines)), epsilon=0.99, n_samples=1)
imp_policy.models = models
A3 = imp_policy.get_action(X_copy3)
print(n_population)
print(A3.shape)
Y3 = population3.vaccinate(list(range(n_population)), A3)
print("Utility of Our Improved Policy: " + str(est_hist_policy.get_utility(X_copy3, A3, Y3)))

print("Utility of Our Improved Policy: " + str(est_hist_policy.get_utility(X_copy3, A3, Y3)))

np.sum(np.sum(A3, axis=1) > 0)

# utility error bounds of the historical policy on the historical data
error_bound_n = 10
policies = [true_hist_policy, est_hist_policy, imp_policy]
true_hist_u = []
est_hist_u = []
imp_pol_u = []
resutls = [true_hist_u, est_hist_u, imp_pol_u]

for i in range(error_bound_n):
  for j in range(len(policies)):
    X_copy = copy.deepcopy(X)
    population_copy = copy.deepcopy(population)
    A = policies[j].get_action(X_copy)
    Y = population_copy.vaccinate(list(range(n_population)), A)
    resutls[j].append(policies[0].get_utility(X_copy, A, Y))

true_mean = np.mean(true_hist_u)
est_mean = np.mean(est_hist_u)
imp_mean = np.mean(imp_pol_u)
true_std = np.std(true_hist_u)
est_std = np.std(est_hist_u)
imp_std = np.std(imp_pol_u)

# Define labels, positions, bar heights and error bar heights
labels = ['True Historical', 'Estimated Historical', 'Improved Policy']
x_pos = np.arange(len(labels))
CTEs = [true_mean, est_mean, imp_mean]
error = [true_std, est_std, imp_std]

# Build the plot
plt.bar(x_pos, CTEs, yerr=error, align='center', alpha=0.5, ecolor='black', 
        capsize=10)
plt.ylabel('Utility on Historical Data')
plt.xticks(x_pos, labels)
plt.title('Average Utility over 10 repetitions')
plt.show()

# utility of the historical and improved policies on new data


# Create new population
print("Generating new population")
population_new = Population(n_genes, n_vaccines, n_treatments)
# with previous vaccines
X_new = population_new.generate(n_population)

#print("Utility of Estimated Historical Policy: " + str(get_utility(X_new, est_hist_policy)))
#print("Utility of True Historical Policy: " + str(get_utility(X_new, true_hist_policy)))
#print("Utility of Our Improved Policy: " + str(get_utility(X_new, imp_policy)))


# utility error bounds of the historical policy on new data data
error_bound_n = 10

# true_hist_u = []
# est_hist_u = []
# imp_pol_u = []
# for i in range(error_bound_n):
#   true_hist_u.append(get_utility(X_new, true_hist_policy))
#   est_hist_u.append(get_utility(X_new, est_hist_policy))
#   imp_pol_u.append(get_utility(X_new, imp_policy))

policies = [true_hist_policy, est_hist_policy, imp_policy]
true_hist_u = []
est_hist_u = []
imp_pol_u = []
resutls = [true_hist_u, est_hist_u, imp_pol_u]

for i in range(error_bound_n):
  for j in range(len(policies)):
    X_copy = copy.deepcopy(X_new)
    population_copy = copy.deepcopy(population_new)
    A = policies[j].get_action(X_copy)
    #print("sum: " + str(np.sum(A)))
    Y = population_copy.vaccinate(list(range(n_population)), A)
    #print("sum Y: " + str(np.sum(Y)))
    resutls[j].append(policies[0].get_utility(X_copy, A, Y))

print(true_hist_u)
print(est_hist_u)
print(imp_pol_u)
true_mean = np.mean(true_hist_u)
est_mean = np.mean(est_hist_u)
imp_mean = np.mean(imp_pol_u)
true_std = np.std(true_hist_u)
est_std = np.std(est_hist_u)
imp_std = np.std(imp_pol_u)

# Define labels, positions, bar heights and error bar heights
labels = ['True Historical', 'Estimated Historical', 'Improved Policy']
x_pos = np.arange(len(labels))
CTEs = [true_mean, est_mean, imp_mean]
error = [true_std, est_std, imp_std]

# Build the plot
plt.bar(x_pos, CTEs, yerr=error, align='center', alpha=0.5, ecolor='black', 
        capsize=10)
plt.ylabel('Utility on Simulated Data')
plt.xticks(x_pos, labels)
plt.title('Average Utility over 10 repetitions')
plt.show()

labels = ['Estimated Historical', 'Improved Policy']
x_pos = np.arange(len(labels))
CTEs = [est_mean, imp_mean]
error = [est_std, imp_std]

# Build the plot
plt.bar(x_pos, CTEs, yerr=error, align='center', alpha=0.5, ecolor='black', 
        capsize=10)
plt.ylabel('Utility on Simulated Data')
plt.xticks(x_pos, labels)
plt.title('Average Utility over 10 repetitions')
plt.show()

# for a list of epsilons, population X and vaccination probability p, 
# returns the utilities
def get_utilities_old(epsilons, X, p):
  utilities = []
  for val in epsilons:
    vaccine_policy = SimplePolicy(n_vaccines, list(range(-1,n_vaccines)), p, val)
    A = vaccine_policy.get_action(X)
    Y = population.vaccinate(list(range(n_population)), A)
    utilities.append(vaccine_policy.get_utility(X, A, Y))
  return utilities

def get_utilities(epsilons, vaccine_policy):
  utilities = []
  for val in epsilons:
    print("Generating population")
    population = Population(n_genes, n_vaccines, n_treatments)
    X = population.generate(n_population)
    vaccine_policy.epsilon = val
    A = vaccine_policy.get_action(X)
    #print(np.sum(A))
    Y = population.vaccinate(list(range(n_population)), A)
    #print(np.sum(Y))
    utilities.append(est_hist_policy.get_utility(X, A, Y))
    #print(utilities)
  return utilities

## Baseline simulator parameters
n_genes = 128
n_vaccines = 3
n_treatments = 4
n_population = 10000

# Create the underlying population


# plot the results

epsilons = np.arange(0.1,1,0.1)
#vaccination_prob = 0.9
utilities = get_utilities(epsilons, imp_policy)
plt.plot(epsilons, utilities)
plt.scatter(epsilons, utilities)
plt.xlabel("Epsilon")
plt.ylabel("Utility")
plt.title("Utility of a differentially private policy for different epsilon values")
plt.show()



# Fairness
## Baseline simulator parameters
n_genes = 128
n_vaccines = 3
n_treatments = 4
n_population = 10000

# Create the underlying population
print("Generating population")
population = Population(n_genes, n_vaccines, n_treatments)
X = population.generate(n_population)

age_ind = 10
gender_ind = 11
income_ind = 12

def split_according_to_protected(data, ind, val):
  X_1 = data[data[:,ind]<val]
  X_2 = data[data[:,ind]>=val]
  return X_1, X_2

def plot_vaccines(x_1, x_2, l1, l2, title):
  y = [0, np.sum(x_1[:,-3]>0)/len(x_1), np.sum(x_1[:,-2]>0)/len(x_1), np.sum(x_1[:,-1]>0)/len(x_1)]
  unvaccinated_y = np.sum(x_1[:,-3:], axis=1)==0
  y[0] = np.sum(unvaccinated_y)/len(x_1)

  z = [0, np.sum(x_2[:,-3]>0)/len(x_2), np.sum(x_2[:,-2]>0)/len(x_2), np.sum(x_2[:,-1]>0)/len(x_2)]
  unvaccinated_z = np.sum(x_2[:,-3:], axis=1)==0
  z[0] = np.sum(unvaccinated_z)/len(x_2)

  print(len(x_1))
  print(y)
  print(len(x_2))
  print(z)

  ax = plt.subplot(111)
  ticks = np.arange(4)
  ax.bar(ticks-0.1, y, width=0.2, color='b', label=l1, align='center')
  ax.bar(ticks+0.1, z, width=0.2, color='g', label=l2, align='center')
  plt.xticks(ticks, ["Unvaccinated", "Vaccine1", "Vaccine2", "Vaccine3"])
  ax.set_ylabel("Percentages %")
  ax.set_title(title)
  plt.legend()
  plt.show()

x1, x2 = split_according_to_protected(X, 11, val=1)
plot_vaccines(x1, x2, "Male", "Female", "Vaccinations According to Gender")

plt.hist(X[:,10])
plt.ylabel("Number of People")
plt.xlabel("Age")
plt.title("Age Histogram")
plt.show()

split_val = 55
x1, x2 = split_according_to_protected(X, 10, val=split_val)
plot_vaccines(x1, x2, "age<"+str(split_val), "age>="+str(split_val), "Vaccinations According to Age Group")

plt.hist(X[:,12])
plt.ylabel("Number of People")
plt.xlabel("Income")
plt.title("Income Histogram")
plt.show()

split_val = 15000
x1, x2 = split_according_to_protected(X, 12, val=split_val)
plot_vaccines(x1, x2, "income<"+str(split_val), "income>="+str(split_val), "Vaccinations According to Income Group")

#vaccine_policy = SimplePolicy(n_vaccines, list(range(-1,n_vaccines)), 0.7, 0.99)
vaccine_policy = imp_policy
vaccine_policy.epsilon = 0.99
A = vaccine_policy.get_action(X)
Y = population.vaccinate(list(range(n_population)), A)

new_pop = np.zeros(X.shape)
new_pop[:,:-3] = X[:,:-3]
new_pop[:,-3:] = A

split_val = 55
x1, x2 = split_according_to_protected(new_pop, 10, val=split_val)
plot_vaccines(x1, x2, "age<"+str(split_val), "age>="+str(split_val), "Actions (Vaccinations) According to Age Group")

x1, x2 = split_according_to_protected(new_pop, 11, val=1)
plot_vaccines(x1, x2, "Male", "Female", "Actions (Vaccinations) According to Gender")

split_val = 15000
x1, x2 = split_according_to_protected(new_pop, 12, val=split_val)
plot_vaccines(x1, x2, "income<"+str(split_val), "income>="+str(split_val), "Actions (Vaccinations) According to Income Group")

symptom_names_list = ['Covid-Recovered', 'Covid-Positive', 'Taste', 'Fever',
                      'Headache', 'Pneumonia', 'Stomach', 'Myocarditis',
                      'Blood-Clots', 'Death']


def get_symptom_action(A,Y):
  results = np.zeros((len(symptom_names_list), 1+n_vaccines))
  for i in range(1+n_vaccines):
    if i == 0:
      curr_idx = np.sum(A, axis=1) == 0
    else:
      curr_idx = A[:,i-1]>0
    results[:,i] = np.mean(Y[curr_idx,:10], axis=0)
  return results
    


def get_group_results(X, A, Y, ind, val=None):
  group1 = X[:,ind]<val
  group2 = X[:,ind]>=val
  results1 = get_symptom_action(A[group1,:],Y[group1,:])
  results2 = get_symptom_action(A[group2,:],Y[group2,:])
  return [results1, results2]


def plot_outcomes(results, titles):
  labels = ['No Vaccine', 'Vaccine1', 'Vaccine2', 'Vaccine3']
  x = np.arange(len(labels))  # the label locations
  width = 0.1  # the width of the bars
  fig = plt.figure()
  fig.set_figheight(3)
  fig.set_figwidth(15)
  rects = []
  #ax = plt.subplot(111)
  for j in range(1,3):
    ax = fig.add_subplot(1,2,j)
    res = results[j-1]
    for i in range(len(symptom_names_list)):
        if i < 5:
            location = x - (width)*(5-i)
        else:
            location = x + (width)*(i-5)
        rects.append(ax.bar(location, res[i], width, label=symptom_names_list[i]))        
    ax.set_ylabel('Percentages %')
    ax.set_title(titles[j-1])
    ax.set_xticks(x)
    ax.set_xticklabels(labels)
    ax.legend(loc="upper center")
  fig.tight_layout()
  plt.show()


results = get_group_results(X, A, Y, 10, val=55)
plot_outcomes(results, ["age<55", "age>=55"])

results = get_group_results(X, A, Y, 11, 1)
plot_outcomes(results, ["Male", "Female"])

results = get_group_results(X, A, Y, 12, 15000)
plot_outcomes(results, ["Income<15000", "Income>=15000"])

